# -*- coding: utf-8 -*-
"""montsec_so2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18eVe6YcrjCNZFo8W1_3skZdoec0T-G0B
"""

# Importem les llibreries necessaries per analitzar les dades

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# from scipy.stats import shapiro, kstest, anderson

# Carreguem l'arxiu .CSV per crear un DataFrame

file_path = '/content/S02.csv'
data = pd.read_csv(file_path)

display(data) # Comprovem que s'hagi carregat correctament visualitzant-lo

# Per l'analisi ens quedem amb les columnes de concentració per hores i els dies
# les demés les podem obviar

selected_columns = data.loc[:, ['data'] + [f'h{i:02}' for i in range(1, 25)]]
display(selected_columns)

transposed_data = selected_columns.T # Transposem les columnes de h01 a h24 per files
display(transposed_data)

# Convertir dades a una sola columna utilitzant stack(), mantenint valors (NaN)
# Es similar a l'instrucció =TOCOL de Google Spreadsheets
future_stack=True # Es silencia el warning referent al update de l'operador stack()

data_column = selected_columns.iloc[0:,1:].stack(dropna=False).reset_index(drop=True)
data_column = data_column.to_frame(name='Concentració') # Convertir a DataFrame
data_column

# Ordenar les dades de la columna 'Concentració' de més petit a més gran

data_sorted = data_column.sort_values(by=['Concentració'], ascending=True)
data_sorted = data_sorted.reset_index(drop=True) # Reset de l'index
data_sorted

# Calcular frequencia Weibull utilitzant aproximació fórmula empírica i/(N+1)

N = len(data_sorted)
data_sorted['Weibull'] = [(i + 1) / (N + 1) for i in range(N)]
display(data_sorted)

# Representem els resultats; encara no sabem si es segueix una distribució log-Normal...

plt.figure(figsize=(10, 6))  # Ajustar per a millor visualització
plt.plot(data_sorted['Concentració'], data_sorted['Weibull'], linestyle='-', linewidth=1, color='gray', zorder=1) # Line plot for connection
plt.scatter(data_sorted['Concentració'], data_sorted['Weibull'], marker='o', s=20, alpha=0.7, color='blue', zorder=2) # Scatter plot for individual points
plt.xlabel('Concentration Values'), plt.ylabel('Weibull Frequency')
plt.title('Weibull Frequency vs. Concentration Values')
plt.grid(True)
plt.show()

# Apliquem el logaritme neperià per als valors de concentració, d'igual manera podriem,
# treballar sobre eix logarítmic pels valors de freqüencia de l'eix y

data_sorted['ln_Concentració'] = np.log(data_sorted['Concentració'])
display(data_sorted)

# Calculem la mitjana i la desviació estàndar de ln_Concentració

mean_ln_concentracio = data_sorted['ln_Concentració'].mean()
std_ln_concentracio = data_sorted['ln_Concentració'].std()
data_sorted['standardized_ln_concentracio'] = (data_sorted['ln_Concentració'] - mean_ln_concentracio) / std_ln_concentracio
# S'ha creat una nova columna al DataFrame

display(data_sorted)

# En aquest gràfic ja podem decidri si les dades segueixen un especte de linia recta doncs;
# seguiran una distribució log-Normal

plt.figure(figsize=(10, 6))
plt.plot(data_sorted['standardized_ln_concentracio'], data_sorted['ln_Concentració'], marker='o', linestyle='-')
plt.xlabel('Standardized ln_concentracio')
plt.ylabel('ln_concentracio')
plt.title('ln_concentracio vs. Standardized ln_concentracio')
plt.grid(True)
plt.show()